# Java Grep Application

## 1. Introduction

This project is a Java implementation of a simplified version of the Linux `grep -r` command.

It started as a **basic object-oriented implementation**, then was **refactored using Java 8 Lambdas and Streams**, and finally **Dockerized** so that it can be executed in a portable, reproducible way on any machine with Docker installed.

The application supports:

- Recursive search through a directory tree
- Regex-based pattern matching
- Output formatted as `filePath:line`
- Logging via SLF4J
- Containerized execution via Docker

---

## 2. Tech Stack & Project Structure

### Tech Stack

This project is built using the following technologies:

- **Language:** Java 8
- **Build Tool:** Maven
- **Logging:** SLF4J with Log4j backend
- **Containerization:** Docker
- **Version Control:** Git

Java 8 is used to support **Lambda expressions and Streams**, which are core to the functional-style refactor of the application.  
Maven is responsible for dependency management and building the **fat JAR**.  
SLF4J + Log4j provides structured and configurable logging.  
Docker ensures the application runs consistently across different environments.

---

### Project Structure

Below is the typical structure of the project:

- core_java/grep
    - src/main/java/ca/jrvs/apps/practice/
        - GrepApp.java
        - JavaGrep.java
        - JavaGrepImpl.java
    - src/main/resources/
        - log4j.properties
    - data/
        - txt/
    - out/
    - pom.xml
    - Dockerfile

**Key Components:**

- **GrepApp.java**  
  Application entry point. Responsible for parsing command-line arguments and triggering the grep execution.

- **JavaGrep.java**  
  Interface defining the core grep behaviors.

- **JavaGrepImpl.java**  
  Concrete implementation of the grep logic using Java 8 Streams and Lambdas.

- **log4j.properties**  
  Logging configuration file for SLF4J + Log4j.

- **Dockerfile**  
  Used to build a container image for the application.
---
## 3. Usage (Local Run & Examples)

### Build the Project

From the `core_java/grep` directory, run the following command to build the project:

mvn clean package

This command will:
- Compile the source code
- Download all required dependencies
- Generate a **fat JAR** file under the `target/` directory

A **fat JAR** means all dependencies are bundled into a single executable JAR file, so the application can be run with one command.

---

### Run the Application

General command format:

java -jar target/grep-app.jar <regex> <rootPath> <outFile>

**Arguments:**
- `regex` — Java-style regular expression used to match each line
- `rootPath` — Root directory for recursive file search
- `outFile` — Output file path to store matched results

---

### Example Commands

Search for the word **"Romeo"** in all files under `data/txt` and save results:

java -jar target/grep-app.jar "Romeo" data/txt out/romeo.txt

Search for all lines that contain **numbers**:

java -jar target/grep-app.jar "[0-9]+" data/txt out/numbers.txt

Case-insensitive search for **"juliet"**:

java -jar target/grep-app.jar "(?i)juliet" data/txt out/juliet_case_insensitive.txt

---

### Output Format

Each matched line is written in the following format:

filePath:matchedLine

Example:

data/txt/shakespeare.txt:Enter Romeo and Juliet aloft, at the Window.
---
## 4. Docker (Containerized Execution)

To make the application portable and easy to run in any environment, the project is fully containerized using Docker.  
This allows the grep app to run without installing Java or Maven locally.

---

### Build Docker Image

Before building the Docker image, make sure the project is already packaged:

mvn clean package

Then, from the `core_java/grep` directory, run:

docker build -t grep-app .

This will create a Docker image named `grep-app` which contains:
- A lightweight Java runtime
- The fat JAR generated by Maven
- The application entrypoint

---

### Run Docker Container with Volumes

Because the application needs access to input files and must write output files, **Docker volumes** are used to mount host directories into the container.

First, make sure the output directory exists:

mkdir -p out

Then run the container:

docker run --rm \
-v "$(pwd)"/data:/data \
-v "$(pwd)"/out:/out \
grep-app "<regex>" "/data" "/out/result.txt"

**Argument Mapping:**
- `"<regex>"` → Search pattern
- `"/data"` → Root directory inside container
- `"/out/result.txt"` → Output file path inside container

**Volume Mapping:**
- `$(pwd)/data` → `/data` inside container
- `$(pwd)/out` → `/out` inside container

This ensures the container can:
- Read files from your local `data/` folder
- Write results back to your local `out/` folder

---

### Docker Example

Search for the word **"Romeo"** using Docker:

docker run --rm \
-v "$(pwd)"/data:/data \
-v "$(pwd)"/out:/out \
grep-app "Romeo" "/data" "/out/romeo_docker.txt"

After execution, the result file `romeo_docker.txt` will appear in your local `out/` directory.

---

## 5. Implementation Details & Future Improvements

### Core Grep Logic

The application follows the same high-level workflow as the Linux `grep -r` command:

1. **Recursively traverse the directory tree** starting from `rootPath`
2. **Filter all regular files** and ignore directories
3. **Read each file line by line**
4. **Apply the regex pattern** against each line
5. **Format matched results** as `filePath:line`
6. **Write results to output file and standard output**

---

### Object-Oriented Design

The design follows a clean separation of responsibilities:

- **GrepApp**
    - Acts as the application entry point
    - Validates command-line arguments
    - Triggers the grep execution

- **JavaGrep (Interface)**
    - Defines the core behaviors:
        - File traversal
        - Regex matching
        - Result output

- **JavaGrepImpl (Implementation)**
    - Implements the full grep logic
    - Uses Java 8 Streams and Lambdas to:
        - Walk file paths
        - Filter valid files
        - Process lines in a functional style

This design makes the project:
- Easy to maintain
- Easy to test
- Easy to extend in the future

---

### Stream & Lambda Refactor

The original implementation used:
- Traditional `for` loops
- Manual collection iteration

It was later refactored using:
- `Files.walk()` for directory traversal
- Stream pipelines for:
    - File filtering
    - Line filtering
    - Regex matching
    - Result formatting

This refactor:
- Reduced boilerplate code
- Improved readability
- Made the data flow easier to reason about

---

### Logging Integration (SLF4J)

SLF4J is used as a logging facade with Log4j as the backend.

Logging is applied to:
- File traversal progress
- Regex matching steps
- Exception handling (invalid files, IO errors)

Benefits:
- Easier debugging
- Clear runtime visibility
- Production-style logging experience

---

### Future Improvements

Possible enhancements for the project include:

- Add multi-threaded file processing for large directories
- Support additional grep options:
    - Line numbers
    - File name only output
    - Inverted matching (`-v` behavior)
- Improve error handling for:
    - Permission-denied files
    - Invalid regex input
- Add unit tests using JUnit
- Add CI/CD pipeline for automated builds and testing
- Improve Docker image size using a multi-stage build

---

### Learning Outcomes

This project demonstrates:

- Practical use of Java Streams and Lambda expressions
- Clean separation of interface and implementation
- Building and packaging a Java application with Maven
- Using logging frameworks in a production-style setup
- Dockerizing a Java application with volume mapping
- Following real-world software engineering workflow from:
    - Local development
    - Refactor
    - Logging
    - Containerization



